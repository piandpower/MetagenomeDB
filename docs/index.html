<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>MetagenomeDB</title>
<style type="text/css">

BODY {
	margin: 0;
	padding: 10px;
	font-family: Georgia, serif;
	font-size: 16px;
	color: #000;
}

PRE {
	font-family: Fixedsys, Monaco, Courier;
	font-size: 10pt;
	padding: 2px 0 2px 7pt;
	border-left: 5px solid #d2f2f1;
	margin-left: 40px;
	color: #003f3f;
	background: #faffff;
	overflow: auto;
	width: 90%;
 }

CODE, TT {
	font-family: Fixedsys, Monaco, Courier;
	font-size: 10pt;
	color: #8F1D00;
 }

H1.title {
	margin-top: 0px;
	font-size: 21px;
	border: none;
	text-align: left;
}

H1 {
	font-size: 19px;
	border-bottom: 1px solid #aaa;
	margin-top: 20px;
}

H2 {
	font-size: 18px;
	margin-left: 20px;
	margin-top: 20px;
}

H3 {
	font-size: 16px;
	margin-left: 20px;
}

H4 {
	font-size: 16px;
	margin-left: 20px;
	font-weight: normal;
}

P {
	text-indent: 20px;
}

A, A:hover, A:visited {
	color: #000;
	text-decoration: none;
	text-transformation: none;
	border-bottom: 1px dashed #aaa;	
}

H2 > A, H2 > A:hover, H2 > A:visited,
H3 > A, H3 > A:hover, H3 > A:visited,
H4 > A, H4 > A:hover, H4 > A:visited,
DIV.contents * A, DIV.contents * A:visited {
	border-bottom: none;
}

DIV.note {
	border: 1px solid #7099C5;
	background: #f4ffff;
	padding: 0;
	margin-left: 20px;
	margin-right: 20px;
	-webkit-border-radius: 8px;
	-moz-border-radius: 8px;
}

DIV.note > P.first {
	font-weight: bold;
	display: inline;
	padding: 4px 0 0 4px;
}
</style>
</head>
<body>
<div class="document" id="metagenomedb">
<h1 class="title">MetagenomeDB</h1>

<p>Welcome to the <a class="reference external" href="http://github.com/ajmazurie/MetagenomeDB">MetagenomeDB</a> toolkit documentation. MetagenomeDB allows to represent, manipulate and query metagenomic data using the <a class="reference external" href="http://www.python.org">Python</a> programming language. All the data are transparently handled by a <a class="reference external" href="http://www.mongodb.org">MongoDB</a> server, a professional-grade <a class="reference external" href="http://en.wikipedia.org/wiki/Document-oriented_database">document-oriented</a> database. This database is invisible for the user, who interacts with a high-level Python API. MetagenomeDB is also provided with a set of command-line tools to quickly add, remove and annotate objects in the database.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents:</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#getting-started" id="id3">1&nbsp;&nbsp;&nbsp;Getting started</a></li>
<li><a class="reference internal" href="#basics" id="id4">2&nbsp;&nbsp;&nbsp;Basics</a><ul class="auto-toc">
<li><a class="reference internal" href="#sequences-sequence-class" id="id5">2.1&nbsp;&nbsp;&nbsp;Sequences (<tt class="docutils literal">Sequence</tt> class)</a><ul class="auto-toc">
<li><a class="reference internal" href="#properties" id="id6">2.1.1&nbsp;&nbsp;&nbsp;Properties</a></li>
<li><a class="reference internal" href="#commit-commit-method" id="id7">2.1.2&nbsp;&nbsp;&nbsp;Commit (<tt class="docutils literal">commit()</tt> method)</a></li>
<li><a class="reference internal" href="#query-find-and-find-one-methods" id="id8">2.1.3&nbsp;&nbsp;&nbsp;Query (<tt class="docutils literal">find()</tt> and <tt class="docutils literal">find_one()</tt> methods)</a></li>
<li><a class="reference internal" href="#related-sequences" id="id9">2.1.4&nbsp;&nbsp;&nbsp;Related sequences</a><ul class="auto-toc">
<li><a class="reference internal" href="#direction-of-the-relation" id="id10">2.1.4.1&nbsp;&nbsp;&nbsp;Direction of the relation</a></li>
<li><a class="reference internal" href="#filters" id="id11">2.1.4.2&nbsp;&nbsp;&nbsp;Filters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deletion" id="id12">2.1.5&nbsp;&nbsp;&nbsp;Deletion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#collections-collection-class" id="id13">2.2&nbsp;&nbsp;&nbsp;Collections (<tt class="docutils literal">Collection</tt> class)</a><ul class="auto-toc">
<li><a class="reference internal" href="#related-collections" id="id14">2.2.1&nbsp;&nbsp;&nbsp;Related collections</a></li>
<li><a class="reference internal" href="#id2" id="id15">2.2.2&nbsp;&nbsp;&nbsp;Related sequences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#relationships-relationship-class" id="id16">2.3&nbsp;&nbsp;&nbsp;Relationships (<tt class="docutils literal">Relationship</tt> class)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tools" id="id17">3&nbsp;&nbsp;&nbsp;Tools</a><ul class="auto-toc">
<li><a class="reference internal" href="#adding-and-removing-objects" id="id18">3.1&nbsp;&nbsp;&nbsp;Adding and removing objects</a><ul class="auto-toc">
<li><a class="reference internal" href="#the-add-tool" id="id19">3.1.1&nbsp;&nbsp;&nbsp;The <tt class="docutils literal">add</tt> tool</a><ul class="auto-toc">
<li><a class="reference internal" href="#csv-format" id="id20">3.1.1.1&nbsp;&nbsp;&nbsp;CSV format</a></li>
<li><a class="reference internal" href="#json-format" id="id21">3.1.1.2&nbsp;&nbsp;&nbsp;JSON format</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-remove-tool" id="id22">3.1.2&nbsp;&nbsp;&nbsp;The <tt class="docutils literal">remove</tt> tool</a></li>
</ul>
</li>
<li><a class="reference internal" href="#annotating-objects" id="id23">3.2&nbsp;&nbsp;&nbsp;Annotating objects</a></li>
<li><a class="reference internal" href="#importing-sequences" id="id24">3.3&nbsp;&nbsp;&nbsp;Importing sequences</a></li>
<li><a class="reference internal" href="#importing-sequence-alignments" id="id25">3.4&nbsp;&nbsp;&nbsp;Importing sequence alignments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-manipulations" id="id26">4&nbsp;&nbsp;&nbsp;Advanced manipulations</a></li>
<li><a class="reference internal" href="#future-developments" id="id27">5&nbsp;&nbsp;&nbsp;Future developments</a></li>
</ul>
</div>
<div class="section" id="getting-started">
<h1><a class="toc-backref" href="#id3">1&nbsp;&nbsp;&nbsp;Getting started</a></h1>
<p><em>TO DO: Short description of how to install MetagenomeDB and load the API</em></p>
</div>
<div class="section" id="basics">
<h1><a class="toc-backref" href="#id4">2&nbsp;&nbsp;&nbsp;Basics</a></h1>
<p>Imported as a Python library, MetagenomeDB exposes three classes: <tt class="docutils literal">Sequence</tt>, <tt class="docutils literal">Collection</tt> and <tt class="docutils literal">Relationship</tt>, which allow for the representation of virtually any kind of metagenomic data.</p>
<p><tt class="docutils literal">Sequence</tt> and <tt class="docutils literal">Collection</tt> classes can be used to represent sequences and collection of sequences, respectively. <tt class="docutils literal">Relationship</tt> objects can then be used to link sequences to collections, sequences to sequences (e.g., sequence similarity), or collections to collections (e.g., sub-collections).</p>
<p>A firth class, <tt class="docutils literal">Object</tt> is also available to represent any information that wouldn't be a <tt class="docutils literal">Sequence</tt> or a <tt class="docutils literal">Collection</tt>. It allows to extend MetagenomeDB to exotic data; e.g., expression data, or sequences that are not stored in other databases.</p>
<div class="section" id="sequences-sequence-class">
<h2><a class="toc-backref" href="#id5">2.1&nbsp;&nbsp;&nbsp;Sequences (<tt class="docutils literal">Sequence</tt> class)</a></h2>
<div class="section" id="properties">
<h3><a class="toc-backref" href="#id6">2.1.1&nbsp;&nbsp;&nbsp;Properties</a></h3>
<p>The <tt class="docutils literal">Sequence</tt> class stores sequences of any type (DNA, RNA or protein). In order to create a <tt class="docutils literal">Sequence</tt> object, a sequence and a name must be provided as arguments:</p>
<pre class="literal-block">
$ python
Python 2.6.4 (r264:75821M, Oct 27 2009, 19:48:32)
[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import MetagenomeDB as mdb
&gt;&gt;&gt; sequence = mdb.Sequence(sequence = &quot;atgc&quot;, name = &quot;my sequence&quot;)
</pre>
<p>Our sequence has now been declared. It has two properties: <tt class="docutils literal">sequence</tt>, which is a string that represents its sequence, and <tt class="docutils literal">name</tt>, which is any identifier you want to give it. The <tt class="docutils literal">get_properties()</tt> method will list all properties of this object:</p>
<pre class="literal-block">
&gt;&gt;&gt; print sequence.get_properties()
{'length': 4, 'name': 'my sequence', 'sequence': 'atgc'}
</pre>
<p>Note that a third property, <tt class="docutils literal">length</tt> has been added; it is automatically inferred from the <tt class="docutils literal">sequence</tt> property if you do not provide it.</p>
<p>A <tt class="docutils literal">Sequence</tt> object is not limited to those three properties. You can add and modify any property by manipulating your object as a <a class="reference external" href="http://docs.python.org/tutorial/datastructures.html#dictionaries">dictionary</a>:</p>
<pre class="literal-block">
&gt;&gt;&gt; sequence[&quot;my_property&quot;] = 3
&gt;&gt;&gt; print sequence[&quot;my_property&quot;]
3
&gt;&gt;&gt; sequence[&quot;my_property&quot;] = [1,2,3]
&gt;&gt;&gt; print sequence.get_properties()
{'my_property': [1,2,3], 'length': 4, 'name': 'my sequence', 'sequence': 'atgc'}
&gt;&gt;&gt; &quot;my_property&quot; in sequence
True
&gt;&gt;&gt; del sequence[&quot;my_property&quot;]
</pre>
<p>MetagenomeDB supports nested properties; i.e., properties that are children of other properties. Creating such a nested property requires the use of the dot notation:</p>
<pre class="literal-block">
&gt;&gt;&gt; sequence[&quot;my_property.my_subproperty&quot;] = &quot;something&quot;
&gt;&gt;&gt; print sequence.get_properties()
&gt;&gt;&gt; {'my_property': {'my_subproperty': 'something'}, 'length': 4, 'name': 'my sequence', 'sequence': 'atgc'}
</pre>
<p>Note that the property <tt class="docutils literal">my_property</tt> now has a sub-property <tt class="docutils literal">my_subproperty</tt>. Accessing and modifying this sub-property can be done user either the dot notation or a more traditional Python dictionary notation:</p>
<pre class="literal-block">
&gt;&gt;&gt; print sequence[&quot;my_property&quot;][&quot;my_subproperty&quot;]
'something'
&gt;&gt;&gt; print sequence[&quot;my_property.my_subproperty&quot;]
'something'
&gt;&gt;&gt; sequence[&quot;my_property&quot;][&quot;my_subproperty&quot;] = &quot;something else&quot;
&gt;&gt;&gt; sequence[&quot;my_property.my_subproperty&quot;] = &quot;something different&quot;
</pre>
<p>Nested properties are useful to group related properties; e.g., information about who produced this sequence, and how:</p>
<pre class="literal-block">
&gt;&gt;&gt; sequence[&quot;author.name&quot;] = &quot;me&quot;
&gt;&gt;&gt; sequence[&quot;author.institution&quot;] = &quot;my employer&quot;
&gt;&gt;&gt; print sequence[&quot;author&quot;]
{'name': 'me', 'institution': 'my employer'}
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">By convention you cannot create, delete or modify properties whose name starts with an underscore (_). Those are for reserved properties.</p>
</div>
</div>
<div class="section" id="commit-commit-method">
<h3><a class="toc-backref" href="#id7">2.1.2&nbsp;&nbsp;&nbsp;Commit (<tt class="docutils literal">commit()</tt> method)</a></h3>
<p>At this stage the sequence object you created and annotated exists only in the memory of your computer. It is <cite>uncommitted</cite>, as shown when printing the sequence description:</p>
<pre class="literal-block">
&gt;&gt;&gt; print sequence
&lt;Sequence id:none name:'my sequence' length:4 state:'uncommitted'&gt;
</pre>
<p>To <cite>commit</cite> this object to the database, just call its <tt class="docutils literal">commit()</tt> method:</p>
<pre class="literal-block">
&gt;&gt;&gt; sequence.commit()
&gt;&gt;&gt; print sequence
&lt;Sequence id:4be9b417aeba8aa576000000 name:'my sequence' length:4 state:'committed'&gt;
</pre>
<p>Your object received an internal identifier, which prove it was stored into the database. If you happen to modify this object <cite>after</cite> it is committed, you will need to commit it again to store the modifications:</p>
<pre class="literal-block">
&gt;&gt;&gt; del sequence[&quot;author&quot;]
&gt;&gt;&gt; print sequence
&lt;Sequence id:4be9b417aeba8aa576000000 name:'my sequence' length:4 state:'uncommitted'&gt;
&gt;&gt;&gt; sequence.commit()
&gt;&gt;&gt; print sequence
&lt;Sequence id:4be9b417aeba8aa576000000 name:'my sequence' length:4 state:'committed'&gt;
</pre>
<p>To know if an object was committed after its latest modification, you can either read its description or call <tt class="docutils literal">is_committed()</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; print sequence.is_committed()
True
</pre>
</div>
<div class="section" id="query-find-and-find-one-methods">
<h3><a class="toc-backref" href="#id8">2.1.3&nbsp;&nbsp;&nbsp;Query (<tt class="docutils literal">find()</tt> and <tt class="docutils literal">find_one()</tt> methods)</a></h3>
<p>Sequences that have been committed can be queried based on any of their properties. It is important to note that uncommitted objects are <cite>not</cite> visible by those queries.</p>
<p>Two methods of the <tt class="docutils literal">Sequence</tt> class are available to query sequences: <tt class="docutils literal">find()</tt>, and <tt class="docutils literal">find_one()</tt>. The former returns all sequences that match the query, while the latter returns only the first. This can be useful when you know there is only one sequence that can match your query, or if you only want one example of sequence that match this query.</p>
<p>Queries are expressed as a filter; i.e., you provide a set of properties and the values you are looking for, and MetagenomeDB will return the sequences that match:</p>
<pre class="literal-block">
&gt;&gt;&gt; mdb.Sequence.find_one(name = &quot;my sequence&quot;)
&lt;Sequence id:4be9b417aeba8aa576000000 name:'my sequence' length:4 state:'committed'&gt;
&gt;&gt;&gt; list(mdb.Sequence.find(length = 4))
[&lt;Sequence id:4be9b417aeba8aa576000000 name:'my sequence' length:4 state:'committed'&gt;]
</pre>
<p>Note: the <tt class="docutils literal">find_one()</tt> method returns the object that match your query, or <tt class="docutils literal">None</tt> if there is none. However the <tt class="docutils literal">find()</tt> method returns a list of objects as a Python <a class="reference external" href="http://en.wikipedia.org/wiki/Iterator#Python">generator</a>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for s in mdb.Sequence.find(length = 4):
...     print s
&lt;Sequence id:4be9b417aeba8aa576000000 name:'my sequence' length:4 state:'committed'&gt;
</pre>
<p>You can query for several properties at once:</p>
<pre class="literal-block">
&gt;&gt;&gt; list(mdb.Sequence.find(length = 4, my_property = &quot;something&quot;))
</pre>
<p>If no parameter is provided for <tt class="docutils literal">find()</tt> or <tt class="docutils literal">find_one()</tt>, all objects or the first committed object are returned, respectively.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>Due to technical limitations, nested properties cannot be queried using dot notation:</p>
<pre class="literal-block">
&gt;&gt;&gt; list(mdb.Sequence.find(my_property.my_subproperty = &quot;something&quot;))
  File &quot;&lt;stdin&gt;&quot;, line 1
SyntaxError: keyword can't be an expression
</pre>
<p>Instead, you must declare them as nested dictionaries:</p>
<pre class="literal-block">
&gt;&gt;&gt; list(mdb.Sequence.find(my_property = {&quot;my_subproperty&quot;: &quot;something&quot;}}))
</pre>
<p>This command will select all sequences of which nested property <tt class="docutils literal">my_property.my_subproperty</tt> is equal to 'something'.</p>
<p class="last"><cite>TODO: Do something about this; maybe by allowing some syntactic sugar?</cite></p>
</div>
</div>
<div class="section" id="related-sequences">
<h3><a class="toc-backref" href="#id9">2.1.4&nbsp;&nbsp;&nbsp;Related sequences</a></h3>
<p>Two <tt class="docutils literal">Sequence</tt> objects can be related because the sequences they represent are similar, or because one is a subsequence of another. The <tt class="docutils literal">get_related_sequences()</tt> method gives access to these related sequences.</p>
<p>This method takes three arguments: a direction for the relationship (<tt class="docutils literal">direction</tt>), a sequence filter (<tt class="docutils literal">sequence_filter</tt>) and a relationship filter (<tt class="docutils literal">relationship_filter</tt>).</p>
<div class="section" id="direction-of-the-relation">
<h4><a class="toc-backref" href="#id10">2.1.4.1&nbsp;&nbsp;&nbsp;Direction of the relation</a></h4>
<p>The <tt class="docutils literal">direction</tt> argument is the direction of the relationship existing between the original <tt class="docutils literal">Sequence</tt> and possible related sequences. The value <tt class="docutils literal">Sequence.INGOING</tt> (or <tt class="docutils literal">Sequence.REFERRING</tt>) will select related sequences that <cite>refers to</cite> the original <tt class="docutils literal">Sequence</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for sequence, relationship in s.get_related_sequences(mdb.Sequence.INGOING):
...    print sequence
</pre>
<p>Note that <tt class="docutils literal">get_related_sequences()</tt> returns two objects at each iteration: the related sequence, and the relationship between this related sequence and the original <tt class="docutils literal">Sequence</tt>.</p>
<p>The value <tt class="docutils literal">Sequence.OUTGOING</tt> (or <tt class="docutils literal">Sequence.REFERRED</tt>) will select related sequences that <cite>are referred to</cite> by the original <tt class="docutils literal">Sequence</tt>. Those two directions express different ways sequences can be related. For example, a sequence A can be a part of a sequence B, but not the opposite. Hence, A <cite>refers to</cite> B while B <cite>is referred to</cite> by A:</p>
<pre class="literal-block">
&gt;&gt;&gt; A = mdb.Sequence(sequence = &quot;atgc&quot;, name = &quot;a&quot;)
&gt;&gt;&gt; B = mdb.Sequence(sequence = &quot;cgcatgccgc&quot;, name = &quot;b&quot;)
&gt;&gt;&gt; r = mdb.Relationship(source = A, target = B, type = &quot;part-of&quot;)
&gt;&gt;&gt; r.commit()
&gt;&gt;&gt; for sequence, relationship in A.get_related_sequences(mdb.Sequence.INGOING):
...    print sequence
&gt;&gt;&gt; _
</pre>
<p>Nothing will be displayed here: no sequence <cite>refers to</cite> A.</p>
<pre class="literal-block">
&gt;&gt;&gt; for sequence, relationship in A.get_related_sequences(mdb.Sequence.OUTGOING):
...    print sequence
&lt;Sequence id:4bfae082aeba8a6612000001 name:'b' length:10 state:'committed'&gt;
</pre>
<p>However, B is <cite>referred to</cite> by A.</p>
<p>Conversely, for B:</p>
<pre class="literal-block">
&gt;&gt;&gt; for sequence, relationship in B.get_related_sequences(mdb.Sequence.INGOING):
...    print sequence
&lt;Sequence id:4bfae081aeba8a6612000000 name:'a' length:4 state:'committed'&gt;
</pre>
<p>The sequence A is indeed <cite>referring to</cite> B.</p>
<pre class="literal-block">
&gt;&gt;&gt; for sequence, relationship in B.get_related_sequences(mdb.Sequence.OUTGOING):
...    print sequence
&gt;&gt;&gt; _
</pre>
<p>However, no sequence is <cite>referred to</cite> by B.</p>
<p>The value <tt class="docutils literal">Sequence.BOTH</tt> will select all related sequences, regardless of the direction.</p>
</div>
<div class="section" id="filters">
<h4><a class="toc-backref" href="#id11">2.1.4.2&nbsp;&nbsp;&nbsp;Filters</a></h4>
<p>When looking for related sequences a filter can be applied at two levels: on the candidate related sequences, and on the relationship between the original <tt class="docutils literal">Sequence</tt> and those candidates.</p>
<p>In both cases the filters are expressed as for the <tt class="docutils literal">find()</tt> and <tt class="docutils literal">find_one()</tt> methods; i.e., as a set of properties and values that the related sequences or their relationships must possess:</p>
<pre class="literal-block">
&gt;&gt;&gt; for s, relationship in A.get_related_sequences(mdb.Sequence.BOTH, sequence_filter = {&quot;name&quot;: &quot;b&quot;}):
...    print sequence
&lt;Sequence id:4bfae082aeba8a6612000001 name:'b' length:10 state:'committed'&gt;
&gt;&gt;&gt; for s, relationship in A.get_related_sequences(mdb.Sequence.BOTH, relationship_filter = {&quot;type&quot;: &quot;part-of&quot;}):
...    print sequence
&lt;Sequence id:4bfae082aeba8a6612000001 name:'b' length:10 state:'committed'&gt;
</pre>
</div>
</div>
<div class="section" id="deletion">
<h3><a class="toc-backref" href="#id12">2.1.5&nbsp;&nbsp;&nbsp;Deletion</a></h3>
<p>A <tt class="docutils literal">Sequence</tt> object can be removed from the database by calling its <tt class="docutils literal">remove()</tt> method:</p>
<pre class="literal-block">
&gt;&gt;&gt; B.remove()
&gt;&gt;&gt; print B
&lt;Sequence id:none name:'b' length:10 state:'uncommitted'&gt;
</pre>
<p>Note that the status for the sequence is now set to uncommitted.</p>
<p><cite>TO DO: For now the removal of an object does not remove the relationship it has with other objects. A general framework to detect such orphans should be implemented</cite></p>
</div>
</div>
<div class="section" id="collections-collection-class">
<h2><a class="toc-backref" href="#id13">2.2&nbsp;&nbsp;&nbsp;Collections (<tt class="docutils literal">Collection</tt> class)</a></h2>
<p>The <tt class="docutils literal">Collection</tt> object represents a collection of <tt class="docutils literal">Sequence</tt> and/or <tt class="docutils literal">Collection</tt> objects. In metagenomic a <tt class="docutils literal">Collection</tt> will typically represents a collection of reads produced by a sequencing run, or a set of contigs produced by an assembly.</p>
<p>The only mandatory property when creating a <tt class="docutils literal">Collection</tt> object is a <tt class="docutils literal">name</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; c = mdb.Collection(name = &quot;my collection&quot;)
</pre>
<p>In addition to the methods mentioned earlier, <tt class="docutils literal">Collection</tt> classes have these additional methods:</p>
<div class="section" id="related-collections">
<h3><a class="toc-backref" href="#id14">2.2.1&nbsp;&nbsp;&nbsp;Related collections</a></h3>
<p><em>To write</em></p>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id15">2.2.2&nbsp;&nbsp;&nbsp;Related sequences</a></h3>
<p><tt class="docutils literal">add_sequence()</tt> will add an existing <tt class="docutils literal">Sequence</tt> object to the collection:</p>
<pre class="literal-block">
&gt;&gt;&gt; s = mdb.Sequence.find_one(name = &quot;my_sequence&quot;)
&gt;&gt;&gt; c.add_sequence(s)
</pre>
<p>By default, a <tt class="docutils literal">Relationship</tt> object is created of type 'part-of' between this sequence and the collection. However, a custom <tt class="docutils literal">Relationship</tt> object can be provided as an argument:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; r = mdb.Relationship(type = &quot;part-of&quot;, &quot;my_property&quot; = 1)
&gt;&gt;&gt; c.add_sequence(s, r)
</pre>
</blockquote>
<p><tt class="docutils literal">remove_sequence()</tt> will remove an existing <tt class="docutils literal">Sequence</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; c.remove_sequence(s)
</pre>
<p><cite>TODO: to implement</cite></p>
<p>Accessing the collections a given sequence belong to is done by calling the <tt class="docutils literal">get_collections()</tt> method:</p>
<pre class="literal-block">
&gt;&gt;&gt; s = mdb.Sequence.find_one()
&gt;&gt;&gt; for collection, relationship in s.get_collections():
...    print collection[&quot;name&quot;]
</pre>
<p>Note that the <tt class="docutils literal">get_collections()</tt> method returns two objects at each iteration: one <tt class="docutils literal">Collection</tt> the sequence belong to, and the <tt class="docutils literal">Relationship</tt> that link those two objects. The <tt class="docutils literal">Relationship</tt> object can contain additional information about why this sequence is thought to belong to this collection.</p>
<p>The <tt class="docutils literal">get_collections()</tt> method accepts two arguments: a filter for the <tt class="docutils literal">Collection</tt> objects (<tt class="docutils literal">collection_filter</tt>), and one for the <tt class="docutils literal">Relationship</tt> objects (<tt class="docutils literal">relationship_filter</tt>). Hence, the following code will only select the collections that are of class 'contigs', and of which the sequence is linked through a relationship of type 'part-of':</p>
<pre class="literal-block">
&gt;&gt;&gt; list(s.get_collections(collection_filter = {&quot;class&quot;: &quot;contigs&quot;}, relationship_filter = {&quot;type&quot;: &quot;part-of&quot;}})
</pre>
</div>
</div>
<div class="section" id="relationships-relationship-class">
<h2><a class="toc-backref" href="#id16">2.3&nbsp;&nbsp;&nbsp;Relationships (<tt class="docutils literal">Relationship</tt> class)</a></h2>
<p><em>To write</em></p>
</div>
</div>
<div class="section" id="tools">
<h1><a class="toc-backref" href="#id17">3&nbsp;&nbsp;&nbsp;Tools</a></h1>
<p>In addition to the Python API provided by MetagenomeDB, several command-line tools are available to perform basic operations in batch. They are located in the <tt class="docutils literal">Tools/</tt> directory of your MetagenomeDB installation.</p>
<div class="section" id="adding-and-removing-objects">
<h2><a class="toc-backref" href="#id18">3.1&nbsp;&nbsp;&nbsp;Adding and removing objects</a></h2>
<p>To quickly add or remove a large number of objects in the database two tools are provided, <tt class="docutils literal">add</tt> and <tt class="docutils literal">remove</tt>. They are an alternative to writing a Python script to perform the same operations.</p>
<div class="section" id="the-add-tool">
<h3><a class="toc-backref" href="#id19">3.1.1&nbsp;&nbsp;&nbsp;The <tt class="docutils literal">add</tt> tool</a></h3>
<p>The <tt class="docutils literal">add</tt> command-line tool accepts as an argument a file, either in <a class="reference external" href="http://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> or <a class="reference external" href="http://en.wikipedia.org/wiki/JSON">JSON</a> format, which describe the objects you want to create:</p>
<pre class="literal-block">
$ Tools/add --help
Usage: add [options]

Part of the MetagenomeDB toolkit. Import objects (Sequence, Collection and
Relationship) into the database. Those objects are provided as JSON- or CSV-
formatted descriptions.

Options:
  -h, --help            show this help message and exit
  -i FILENAME, --input=FILENAME
                        Name of the file containing a description of the
                        objects to import
  -f STRING, --format=STRING
                        Format of the input file, either 'json' or 'csv'
                        (default: json)
  --ignore-duplicates   If set, ignore duplicate objects errors
  --ignore-missing      If set, ignore relationships that points to missing
                        objects
  --dry-run             If set, process the input file but does not actually
                        import the objects
  -v VERBOSITY, --verbosity=VERBOSITY
</pre>
<div class="section" id="csv-format">
<h4><a class="toc-backref" href="#id20">3.1.1.1&nbsp;&nbsp;&nbsp;CSV format</a></h4>
<p>The convention for the CSV format is the following:</p>
<ul class="simple">
<li>each line in the file describes one distinct object</li>
<li>each column of the line describes one property of this object. The syntax is the property name (no space allowed) followed by an equal sign, followed by the value for this property; e.g., <tt class="docutils literal">property=value</tt>. The ordering of the properties is not important</li>
<li>at least one column must contain the special property <tt class="docutils literal">_type</tt> to tell the <tt class="docutils literal">add</tt> tool which type of object it is. The legit values are <tt class="docutils literal">Object</tt>, <tt class="docutils literal">Sequence</tt>, <tt class="docutils literal">Collection</tt> or <tt class="docutils literal">Relationship</tt></li>
</ul>
<p>For example, to create a sequence of name 'my_sequence' you would have to write the following line:</p>
<pre class="literal-block">
_type=Sequence,name=my_sequence,sequence=ATGC
</pre>
<p>Relationships are slightly more complex. You have to describe at least the source, target and the type of relationship between source and target. The source is described by two properties, <tt class="docutils literal">source._type</tt> and <tt class="docutils literal">source.name</tt>, to indicate the type and name of the source object, respectively. The target is described the exact same way. Hence, to connect two collections named A and B you would type:</p>
<pre class="literal-block">
_type=Relationship,source._type=Collection,source.name=A,target._type=Collection,target.name=B,type=part-of
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The objects that the relationship is linking have to be declared <em>before</em> the relationship itself.</p>
</div>
<p>Relationships between sequences add another property to the mix: <tt class="docutils literal">source._collection</tt> and/or <tt class="docutils literal">target._collection</tt>, to indicate the collection the <tt class="docutils literal">Sequence</tt> at the source and/or the target belong to, respectively.</p>
<p>For example, to link two sequences X and Y belonging to collections x and y, respectively, you would type:</p>
<pre class="literal-block">
_type=Relationship,source._type=Sequence,source._collection=x,source.name=X,target._type=Sequence,target._collection=y,target.name=X,type=part-of
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Declaring a relationship between an existing <tt class="docutils literal">Sequence</tt> and another object implies this sequence already belong to a <tt class="docutils literal">Collection</tt>. Hence, you cannot use the <tt class="docutils literal">add</tt> tool to link a <tt class="docutils literal">Sequence</tt> to a <tt class="docutils literal">Collection</tt>. You needs to do this programmatically, or through the use of the <tt class="docutils literal">import.sequences</tt> tool.</p>
</div>
</div>
<div class="section" id="json-format">
<h4><a class="toc-backref" href="#id21">3.1.1.2&nbsp;&nbsp;&nbsp;JSON format</a></h4>
<p><em>To write</em></p>
</div>
</div>
<div class="section" id="the-remove-tool">
<h3><a class="toc-backref" href="#id22">3.1.2&nbsp;&nbsp;&nbsp;The <tt class="docutils literal">remove</tt> tool</a></h3>
<p><tt class="docutils literal">add</tt> and <tt class="docutils literal">remove</tt> utilities.</p>
</div>
</div>
<div class="section" id="annotating-objects">
<h2><a class="toc-backref" href="#id23">3.2&nbsp;&nbsp;&nbsp;Annotating objects</a></h2>
<p><tt class="docutils literal">annotate</tt> utility.</p>
</div>
<div class="section" id="importing-sequences">
<h2><a class="toc-backref" href="#id24">3.3&nbsp;&nbsp;&nbsp;Importing sequences</a></h2>
<p>Let's consider the following <a class="reference external" href="http://en.wikipedia.org/wiki/FASTA_format">FASTA</a>-formatted file <tt class="docutils literal">my_sequences.fasta</tt>:</p>
<pre class="literal-block">
&gt;contig00001  numreads=171
TTCTTCACGTGGGAGTGCGTGTCCCACAAGGTCGCGGGTCTACCCTTACGGGAACCCCGC
TTAAGTAGGAGTTAGTGCACAATAATTTAACGTTTTCGGTTCCTATACAGCTCAGAGCTG
TAAGAAATAAAGTTTAAAACTGCAAATATAAAGCCATAACACATGAAAAAGATAACAATA
AACATTGATGAAAAACTAAAGGAGGTTTTTTCTAGATTATGTGAAGAGGAAGGGGTAGAT
ATGGCTCAGGGTATAAGGGAGTTAATTATTGAGGCAATAAATAGGGGCTATATAAACAAG
CAGAGGAAAGAAGGCGTAGAAAAGGTGAGAAAAAACAAGTGAACAATCACACTTCGATTG
TTTTGCAACTTAGGATACAAAAAGAACAGTGC
&gt;contig00002  numreads=13
ttAGGGTTCTTTTCGGCGAGTTTTCTGGTATCCTCAATTTGTTCGTACAGTTCCTTGATA
GGGTTCTCAAAATCAAGGAATTGTCTGTTTGGGTATTGGGGCATAATGATCGTTTAGAAC
GGTAAAATTAGGGGTTCAGATTTTTtCCTGAAAaGATTtGTTTATGAAAAGTCTTTACCC
TTATCTTTGCCGTCCCGAAAACGGACTGAAAGGGATGTTTTTAGGATGATATAACTGGTT
TCCCAGTAATCACGGATCGGTAGTTCAGTTGGTTATCTCGCCTTAGGCGAGACGCCCTGA
GAAAGGCTCTTTTAAATGATTATGTTCTATACTTACATCATAGTAAATAATGATGGTATA
TTCTATAAGGGAAGTACCTCAGACTTTGAGAAAAGGTTAGAACAACACAACGCCGGACTC
AGTCACTACACTAGAGGCAGAGGGCCTTGGAaGCTGGTTTTTGTTCAGGCTTTCtCTTCA
CAAATTGAGGCTGAAGCCTTGGAAAAACGGCTAAAgCGTTGTAATAAAGATTATTTAAAC
TGGTTAATTAAACAaCCAGTTAATATATTGGATCGGTAGTTCAGTTGGTTAGAATGCCG
</pre>
<p>In order to manipulate those sequences we first need to import them into the MetagenomeDB database. A utility, <tt class="docutils literal">import.sequences</tt> is available in the <tt class="docutils literal">Tools/</tt> subdirectory to do so.</p>
<p><tt class="docutils literal">import.sequences</tt> can read sequences in a variety of formats (see <a class="reference external" href="http://www.biopython.org/wiki/SeqIO#File_Formats">here</a> for a list); by default, it expects FASTA files. To list all its options, type <tt class="docutils literal">./import.sequences <span class="pre">--help</span></tt>:</p>
<pre class="literal-block">
$ cd path_to_metagenomedb_installation/Tools
$ ./import.sequences --help
Usage: import.sequences [options]

Part of the MetagenomeDB toolkit. Imports nucleotide or aminoacid sequences
into the database. Those sequences can be in any format supported by Biopython
(see http://biopython.org/wiki/SeqIO).

Options:
  -h, --help            show this help message and exit
  -v VERBOSITY, --verbosity=VERBOSITY

  Sequences:
    -i FILENAME, --input=FILENAME
                        Sequences to import.
    -f STRING, --format=STRING
                        Format of the sequences file. Default: fasta
    -s KEY VALUE, --sequence-property=KEY VALUE
                        Custom sequence property (optional).

  Collection:
    -C STRING, --collection-name=STRING
                        Name of the collection the sequences belong to.
    -c KEY VALUE, --collection-property=KEY VALUE
                        Description of the collection the sequences belong to,
                        as a key/value (optional).
    -r KEY VALUE, --relationship-property=KEY VALUE
                        Custom sequence-to-collection relationship property
                        (optional).
</pre>
<p>Two information must be provided to import sequences: the name of the sequence file (<tt class="docutils literal"><span class="pre">-i</span></tt> or <tt class="docutils literal"><span class="pre">--input</span></tt>), and the <tt class="docutils literal">Collection</tt> the sequences will belong to. The <tt class="docutils literal">Collection</tt> can be either pre-existing; in this case, you can provide its name with the <tt class="docutils literal"><span class="pre">-C</span></tt> or <tt class="docutils literal"><span class="pre">--collection-name</span></tt> option. Or it can be created on the fly, using your own definition (<tt class="docutils literal"><span class="pre">-c</span></tt> or <tt class="docutils literal"><span class="pre">--collection-property</span></tt> option). Note: all sequences in the file will be assigned the same <tt class="docutils literal">Collection</tt>.</p>
<p>Let imagine a collection named <tt class="docutils literal">my_collection</tt> already exists. Then importing <tt class="docutils literal">my_sequences.fasta</tt> is then as easy as:</p>
<pre class="literal-block">
$ ./import.sequences -i path_to/my_sequences.fasta -C my_collection
</pre>
<p>If <tt class="docutils literal">my_collection</tt> didn't exist, you could have created it with the following command line:</p>
<pre class="literal-block">
$ ./import.sequences -i path_to/my_sequences.fasta -c name my_collection
</pre>
<p>In this case, a collection with name 'my_collection' is created prior to the sequences importation. In case the collection already exists an error will be thrown:</p>
<pre class="literal-block">
$ ./import.sequences -i path_to/my_sequences.fasta -c name my_collection
</pre>
</div>
<div class="section" id="importing-sequence-alignments">
<h2><a class="toc-backref" href="#id25">3.4&nbsp;&nbsp;&nbsp;Importing sequence alignments</a></h2>
<p><tt class="docutils literal">import.BLAST</tt> and <tt class="docutils literal">import.FASTA</tt> utilities.</p>
<ul class="simple">
<li>when either the query or hit collection is not provided, the query or hit object that will be registered is a custom object</li>
<li>import.BLAST: several XML tags can be combined to generate either a query or hit id. Python code can also be used to modify the content on those tags on the fly:</li>
</ul>
<p>Example 1:</p>
<pre class="literal-block">
...
&lt;Iteration&gt;
  &lt;Iteration_iter-num&gt;1&lt;/Iteration_iter-num&gt;
  &lt;Iteration_query-ID&gt;1&lt;/Iteration_query-ID&gt;
  &lt;Iteration_query-def&gt;CH0704v-contig00010 length=3963   numreads=678&lt;/Iteration_query-def&gt;
  &lt;Iteration_query-len&gt;3963&lt;/Iteration_query-len&gt;
  &lt;Iteration_hits&gt;
    ...
</pre>
<ul class="simple">
<li>--query-id-getter &quot;&lt;Iteration_query-def&gt;.split()[0]&quot;</li>
</ul>
<p>=       'CH0704v-contig00010' as the query identifier</p>
<p>Example 2:</p>
<pre class="literal-block">
...
&lt;Hit&gt;
  &lt;Hit_num&gt;2&lt;/Hit_num&gt;
  &lt;Hit_id&gt;gi|9625521|ref|NP_039778.1|&lt;/Hit_id&gt;
  &lt;Hit_def&gt;putative integrase [Sulfolobus virus 1] &amp;gt;gi|138570|sp|P20214.1|INTG_SSV1 RecName: Full=Probable integrase &amp;gt;gi|46705|emb|CAA30211.1| ORF D-335 [Sulfolobus spindle-shaped virus 1]&lt;/Hit_def&gt;
  &lt;Hit_accession&gt;NP_039778&lt;/Hit_accession&gt;
  &lt;Hit_len&gt;335&lt;/Hit_len&gt;
  &lt;Hit_hsps&gt;
    &lt;Hsp&gt;
       ...
</pre>
<p>The following syntax, <tt class="docutils literal"><span class="pre">--hit-id-getter</span> <span class="pre">&quot;{'id':</span> &lt;Hit_id&gt;, 'definition': &lt;Hit_def&gt;, 'accession': <span class="pre">&lt;Hit_accession&gt;}&quot;</span></tt> together with no provided hit collection, will create custom objects as hits which will be a dictionary with the three keys 'id', 'definition' and 'accession'</p>
</div>
</div>
<div class="section" id="advanced-manipulations">
<h1><a class="toc-backref" href="#id26">4&nbsp;&nbsp;&nbsp;Advanced manipulations</a></h1>
<ul class="simple">
<li>traverse neighbors (e.g., is there any sequence in any of my descendant collections that have such and such property?)</li>
</ul>
</div>
<div class="section" id="future-developments">
<h1><a class="toc-backref" href="#id27">5&nbsp;&nbsp;&nbsp;Future developments</a></h1>
<p>Data that are abstracted by the MetagenomeDB toolkit are for now handled by a document-oriented database. However metagenomic data are connected in nature (sequences to sequences, sequences to collections, collections to collections) and may be better handled by a graph database with a suitable query language. It would allow for a faster and more intuitive exploration of the data. E.g., some links may be transparently handled as undirected (sequences/collections) while other retain an orientation (sequence/sequence, collection/collection). It will also simplify the deletion of objects that are connected (would equal to the deletion of a subgraph).</p>
</div>
</div>
</body>
</html>
