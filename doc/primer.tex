
\documentclass[handout]{beamer}
%\documentclass{beamer}

\mode<presentation>
{
  \usetheme{Warsaw}
  \setbeamercovered{transparent}
}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}

\title[MetagenomeDB Primer]{MetagenomeDB Primer}

\date[November 5, 2010]

\subject{Talks}

\AtBeginSection[]
{
	\begin{frame}<beamer>{Outline}
		\tableofcontents[currentsection, currentsubsection]
	\end{frame}
}

\AtBeginSubsection[]
{
	\begin{frame}<beamer>{Outline}
		\tableofcontents[currentsection, currentsubsection]
	\end{frame}
}

%\beamerdefaultoverlayspecification{<+->}
\setbeamertemplate{navigation symbols}{}

\def\prompt{>\hspace{-1pt}>\hspace{-1pt}>\/}
\newcommand{\comment}[1]{{\raggedright $\rightarrow$~\textit{\textsf{#1}}}}

\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}{Outline}
	\tableofcontents
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\begin{frame}{What is MetagenomeDB?}
	\textsc{MetagenomeDB} is a Python\footnote{\url{http://www.python.org/}}-based library designed to easily store, retrieve and annotate metagenomic sequences. It provide an API to create and modify two types of objects, namely sequences and collections. Behind the scene, all data are handled to a MongoDB\footnote{\url{http://www.mongodb.org/}} database to ensure reliability and speed.
\end{frame}

\begin{frame}{Sequences and Collections}
	`Sequences' are any sequence a metagenomic project generate; mainly, reads and contigs. Sequences can be annotated and related to other sequences (to represent similarities, or when a sequence is part of another sequence; e.g., reads that are part of a contig).

	\bigskip
	`Collections' are sets of sequences. Collections can also contains sub-collections to represent hierarchies (e.g., replicate sets of reads, or alternative assemblies). Collections can be annotated and related to other sequences and collections.
\end{frame}

\section{Using MetagenomeDB}

\begin{frame}{Content of the MetagenomeDB toolkit}
	\textsc{MetagenomeDB} has two components:
	\begin{itemize}
		\item a library, which can be used in your own Python scripts to access the database, and
		\item a set of command-line tools, which automatize the addition, annotation and deletion of sequences and collections in the database.
	\end{itemize}

	\medskip
	Among the command-line tools you will find utilities to import BLAST and FASTA alignment results, FASTA-formatted sequences, and ACE reads-to-contigs mappings.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Loading the MetagenomeDB library}
	Once installed, \textsc{MetagenomeDB} can be used in any Python program as a module using the \texttt{import} statement:

	\begin{verbatim}
		import MetagenomeDB
	\end{verbatim}

	Alternatively, you can provide an alias to shorten the name of the library:

	\begin{verbatim}
		import MetagenomeDB as mdb
	\end{verbatim}
\end{frame}

\section{Test cases}

\begin{frame}{Organization of this course}
	\begin{block}{Layout}
		\begin{itemize}
			\item 6 weeks (maybe more)
			\item 2-hours sessions
		\end{itemize}
	\end{block}

	\pause
	\bigskip
	Goal: to show you how to turn (\textit{implement}) a task into a working piece of software.

	\pause
	\bigskip
	\begin{block}{Mailing list}
		\url{http://groups.google.com/group/msu-programming-course}
	\end{block}
\end{frame}

\begin{frame}{What is a program?}
	A program is a text file (a \textit{source code}) which contains a list of instructions to manipulate information (an \textit{algorithm}).

	\pause
	\bigskip
	These instructions are written in near-natural language a computer can understand (a \textit{programming language}).

	\pause
	\bigskip
	\textit{Programming} is the activity of writing such source code to achieve a specific task, using the computer's resources---data acquisition, storage, computation, and output.
\end{frame}

\begin{frame}{Why programming?}
	The advantages of programming are
	\begin{itemize}
		\item You can re-use complex pieces of software experts wrote to solve specific problems
		\begin{itemize}
			\pause
			\item Extracting data from obscure or complex file formats (\textit{parsers})
			\pause
			\item Storing huge amount of data without having to care about file management nor ease of retrieval (\textit{databases})
			\pause
			\item Performing complex calculations---statistical tests, equation solving...
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Why programming?}
	\begin{itemize}
		\item You can automatize tasks. If you can write a piece of code to perform a task once, you can perform it as many times as you want
		\begin{itemize}
			\pause
			\item Testing various parameters of an algorithm on the same data
			\pause
			\item Applying a given analysis procedure on many different chunks of data
		\end{itemize}
	\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Programming in Practice}

\subsection{Choosing a language: Python}

\begin{frame}{The Python programming language}
	For this course the programming language we will use is Python (\url{http://www.python.org/}).

	\pause
	\bigskip
	The interests of this language are
	\begin{itemize}
		\item The syntax is very close to written english (much more than Perl or Java, for example)---easy to learn
		\pause
		\item This is an \textit{interpreted} language, meaning the code you write can be `directly' executed by the computer without intermediary \textit{compilation} step---easy to run
		\pause
		\item There is a \textit{shell} available, that allows you to quickly test your code or find documentation on other's code
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The Python programming language}
	\framesubtitle{Example}
	Printing a simple sentence on the screen:
	\begin{verbatim}
		print "Hello, world!"
	\end{verbatim}

	\pause
	Comparing two values:
	\begin{verbatim}
		score_msu = get_score("Montana State University")
		score_um = get_score("University of Montana")

		if (score_msu <= score_um):
		    print "ERROR: This shouldn't happen."
		else:
		    print "Everything is fine."
	\end{verbatim}
\end{frame}

\subsection{Executing a Python program}

\begin{frame}{The Python interpreter}
	`Running' or `executing' a program written in Python requires a Python \textit{interpreter}.

	\bigskip
	An interpreter is a program (written in another language) that reads your instructions and convert them into orders for the computer's CPU.

	\pause
	\bigskip
	The Python interpreter can work in two modes: normal, and \textit{interactive}.
\end{frame}

\begin{frame}
	\frametitle{The Python interpreter}
	\framesubtitle{Normal mode}
	In the normal mode, the Python interpreter reads a file containing your instructions (a \textit{script}) and executes them.

	\bigskip
	The interpreter is invoked on the command line. Any output from your program is displayed there.
\end{frame}

\begin{frame}[fragile]
	\frametitle{The Python interpreter}
	\framesubtitle{Normal mode}

	For example, executing the following file:
	\begin{block}{my\_first\_python\_code.py}
		\begin{verbatim}
			print "Hello, world!"
		\end{verbatim}
	\end{block}

	... will be done this way:
	\begin{block}{Terminal}
		\begin{semiverbatim}
			\textbf{shell%} python ./my_first_python_code.py
			Hello, world!
		\end{semiverbatim}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The Python interpreter}
	\framesubtitle{Normal mode}

	In all Unix systems you can turn a Python script into an executable in two steps.

	\bigskip
	\begin{enumerate}
		\pause
		\item A line must be added as the very beginning of your file:
		\begin{block}{my\_first\_python\_code.py}
			\begin{verbatim}
				#!/bin/env python
				print "Hello, world!"
			\end{verbatim}
		\end{block}
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The Python interpreter}
	\framesubtitle{Normal mode}

	\begin{enumerate}
		\setcounter{enumi}{1}
		\item The file must be set as executable:
			\begin{block}{Terminal}
				\begin{semiverbatim}
					\textbf{shell%} chmod +x my_first_python_code.py
				\end{semiverbatim}
			\end{block}
	\end{enumerate}

	\pause
	\bigskip
	Then, you can execute your script by typing
	\begin{block}{Terminal}
		\begin{semiverbatim}
			\textbf{shell%} ./my_first_python_code.py
		\end{semiverbatim}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The Python interpreter}
	\framesubtitle{Interactive mode}
	In the interactive mode, the Python interpreter reads your instructions as you enter them on the keyboard, and executes them each time you press Enter. It is similar to a Unix shell:

	\medskip
	\begin{block}{Terminal}
		\begin{semiverbatim}
			\textbf{shell%} python
			Python 2.6.4 (r264:75821M, Oct 27 2009) 
			[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
			\prompt print "Hello, world!"
			Hello, world!
			\prompt _
		\end{semiverbatim}
	\end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{First Elements of Programming}

\subsection[Variables: Representing your data]{Variables: Representing your data}

\begin{frame}
	\frametitle{Variables}
	\framesubtitle{What is a variable?}

	In order to manipulate data in a program we first need to \textit{store} it in the computer memory, so it can be retrieved later. The portion of memory devoted to this data is called a \textit{variable}.

	\pause
	\bigskip
	An identifier, or variable \textit{name}, is used to request the content of this variable or alter its value.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{What is a variable?}

	A value is assigned to a variable using the \textit{assignment} statement, $=$.

	\begin{semiverbatim}
		\prompt a \textbf{=} 1
		\prompt print a
		1
	\end{semiverbatim}

	\begin{block}{Note}
		Variable name are case sensitive, so \textit{a} and \textit{A} are two distinct variables.
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Variables}
	\framesubtitle{Types of variable}
	Python proposes different types of variables, that are sufficient to represent any kind of information:

	\begin{itemize}
		\item \textit{numbers}: \texttt{1}, \texttt{-0.3}, \texttt{1e-5}

		\medskip
		\item \textit{strings}: \texttt{"a piece of text"}, \texttt{"another piece"}

		\comment{Strings must be quoted to distinguish them from variable names}

		\medskip
		\item \textit{booleans}: \texttt{True}, \texttt{False}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Variables}
	\framesubtitle{Types of variable}
	Python also proposes powerful \textit{compounds} variable types, used to group together other values.

	\pause
	\begin{itemize}
		\item \textit{lists}, also called \textit{vectors} or \textit{arrays}:

		\texttt{[1, "a piece of text", True]}

		\comment{Symbols `\texttt{[}' and `\texttt{]}' are used to represent the list}

		\pause
		\medskip
		\item \textit{dictionaries}, also called \textit{maps} or \textit{associative arrays}:
		
		\texttt{\{"hello": "bonjour", "bye": "au revoir"\}}

		\comment{Symbols `\texttt{\{}', `\texttt{\}}' and `\texttt{:}' are used to represent the dictionary}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Lists}

	Lists are a succession of values in a specific order, delimited by square brackets. \texttt{[1, 2, 3]} is not the same as \texttt{[3, 2, 1]}.

	\pause
	\bigskip
	List items need not all have the same type. Lists can also contain other lists.
	\begin{semiverbatim}
		\prompt a = \textbf{[}1\textbf{,} 2\textbf{,} 3\textbf{]}
		\prompt b = \textbf{[}"foo"\textbf{,} a\textbf{,} "bar"\textbf{]}
		\prompt print b
		['foo', [1, 2, 3], 'bar']
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Lists}

	We can access any item in a list by its index, starting at 0:
	\begin{semiverbatim}
		\prompt b = ["foo", [1, 3, 4], "bar"]
		\prompt print b\textbf{[0]}
		'foo'
		\prompt print b\textbf{[1]}
		[1, 3, 4]
		\pause
		\prompt print b\textbf{[1][2]}	\comment{Access to nested lists}
		4
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Lists}
	\begin{block}{Note}
	The Python interpreter will report an error if you try to access an item outside of the list's range:

	\begin{semiverbatim}
		\prompt print b[4]	\comment{This shouldn't work!}
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		IndexError: list index out of range
	\end{semiverbatim}

	This process of error reporting is called \textit{exception}. Various exceptions (here, \texttt{IndexError}) are `thrown' by the interpreter depending of the error.
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Lists}

	Using indices we can also modify any item in a list:

	\begin{semiverbatim}
		\prompt b = ["foo", [1, 3, 4], "bar"]
		\prompt print b
		['foo', [1, 3, 4], 'bar']
		\prompt b[1] = True
		\prompt print b
		['foo', True, 'bar']
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Lists}

	Python allows sublist access using the indices of the first and last items (minus one). This is a feature called \textit{slicing}.

	\begin{semiverbatim}
		\prompt c = ["a", "b", "c", "d", "e"]
		\prompt print c[0]	\comment{First item}
		'a'
		\prompt print c\textbf{[}0\textbf{:}3\textbf{]}	\comment{Items 0 to 2 (3-1)}
		['a', 'b', 'c']
		\prompt print c\textbf{[}3\textbf{:]}	\comment{Items from the third one}
		['d', 'e']
		\prompt print c\textbf{[:}4\textbf{]}	\comment{Items up to the fourth}
		['a', 'b', 'c', 'd']
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Lists}

	List indices can also be negatives. In this case they point elements at index \textit{n} - index, with \textit{n} the number of elements in the list.

	\begin{semiverbatim}
		\prompt c = ["a", "b", "c", "d", "e"]
		\prompt print c[-1]	\comment{Item at position 5-1 = 4}
		'e'
		\prompt print c[-3:]	\comment{3 last items}
		['c', 'd', 'e']
		\prompt print c[:-2]	\comment{All items except the two last ones}
		['a', 'b', 'c']
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Lists}

	Lists can be joined with the \texttt{+} operator:
	\begin{semiverbatim}
		\prompt d = [1, 2, 3] + [True, False]
		\prompt print d
		[1, 2, 3, True, False]
	\end{semiverbatim}

	\pause
	Strings can be manipulated as lists (lists of characters):
	\begin{semiverbatim}
		\prompt e = "Montana State University"
		\prompt print e[:7]
		'Montana'
		\prompt print e[8:13]
		'State'
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Dictionaries}

	Dictionaries are special lists, where each element is accessed to using a  \textit{key} rather than an index:

	\begin{semiverbatim}
		f = \textbf{\{} \textit{key1}\textbf{:} \textit{value1}, \textit{key2}\textbf{:} \textit{value2} ... \textbf{\}}
	\end{semiverbatim}

	Note the use of braces (`\{' and `\}'), colons (to separate a key from its value) and commas (to separate multiple key/value pairs, if more than one).
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Dictionaries}

	Example:

	\begin{semiverbatim}
		\prompt f = \textbf{\{}
		...       "aardvark"\textbf{:} "a nocturnal mammal ..."\textbf{,}
		...       "zyzzyva"\textbf{:} "any of various ..."
		...      \textbf{\}}
	\end{semiverbatim}

	\begin{block}{Note}
		Keys must be unique, so that each value is referenced by one (and only one) key. Keys can be of any immutable type (numbers, booleans, strings, tuples).
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Dictionaries}

	Accessing a value in a dictionary requires to know its key:
	\begin{semiverbatim}
		\prompt print f\textbf{[}"aardvark"\textbf{]}
		'a nocturnal mammal ...'
		\pause
		\prompt print f\textbf{[}"!?"\textbf{]}	\comment{This shouldn't work!}
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		KeyError: '!?'
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\frametitle{Dictionaries}

	As for regular lists, any value of a dictionary can be modified:
	\begin{semiverbatim}
		\prompt f["python"] = "a large heavy-bodied ..."
		\prompt print f["python"]
		'a large heavy-bodied ...'
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables}
	\framesubtitle{Altogether}

	Using combinations of strings, numbers, booleans, lists and dictionaries it is possible to describe and manipulate virtually any type of information in Python:

	\begin{semiverbatim}
		\prompt saccharomyces_cerevisiae = \{
		...     "Number of genes": 6400,
		...     "Kingdom": "Fungi",
		...     "Genes": \{
		...        "15S_RRNA": \{ "description": "..." \},
		...        "ZWF1": \{ "locus": "YNL241C" \}
		...      \}
		...   \}
	\end{semiverbatim}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection[Statements: Processing your data]{Statements: Processing your data}

\begin{frame}{Statements}
	A program is written as a succession of \textit{statements} or \textit{commands}.

	\pause
	\bigskip
	A statement is a basic instruction that is given to the Python interpreter for execution.

	\pause
	\bigskip
	A statement is a combination of \textit{keywords}, \textit{values} or \textit{variables}, and possibly some symbols.
\end{frame}

\begin{frame}{Statements}
	Only 29 keywords are used by Python: \texttt{and}, \texttt{assert}, \texttt{break}, \texttt{class}, \texttt{continue}, \texttt{def}, \texttt{del}, \texttt{elif}, \texttt{else}, \texttt{except}, \texttt{exec}, \texttt{finally}, \texttt{for}, \texttt{from}, \texttt{global}, \texttt{if}, \texttt{import}, \texttt{in}, \texttt{is}, \texttt{lambda}, \texttt{not}, \texttt{or}, \texttt{pass}, \texttt{print}, \texttt{raise}, \texttt{return}, \texttt{try}, \texttt{while}, and \texttt{yield}.

	\bigskip
	Among the symbols used: \texttt{:}, \texttt{=}, \texttt{[}, \texttt{]}, \texttt{\{}, \texttt{\}}, and \texttt{\#}.
\end{frame}

\begin{frame}
	\frametitle{Statements}
	\framesubtitle{Types of statements}

	It exists at least 8 types of statements:

	\begin{itemize}
		\item \textbf{assignments} (\texttt{=}), to assign a value to a \textit{variable}
		\item \textbf{arithmetic operators} (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{**}, \texttt{\%}), to combine numbers
		\item \textbf{boolean operators} (\texttt{and}, \texttt{or}, \texttt{not}, $\wedge$, \texttt{in}, \texttt{==}, \texttt{!=} ...), to compare values
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Statements}
	\framesubtitle{Types of statements}

	\begin{itemize}
		\item \textbf{calls} ($print$, $raise$, $exec$ ...), to execute a set of instructions (called \textit{function}, \textit{method} or \textit{sub-program})
		\item \textbf{returns} ($return$, $yield$), to return a value from within a function to the main program
		\item \textbf{branching} ($if$, $elif$, $else$, $try$, $except$, $finally$), to jump to other parts of the program based on the value of a variable
		\item \textbf{iterations} ($for$, $while$), to execute a group of instructions several times
		\item \textbf{special flow controls} ($pass$, $continue$, $break$), to arbitrarily stop the flow of instructions or skip iterations
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Arithmetic operators}

	Python supports all the four basic operators: addition, subtraction, multiplication and division.

	\begin{semiverbatim}
		\prompt 1 \textbf{+} 1
		2
		\prompt 6 \textbf{/} -2
		-3
		\prompt 3 \textbf{*} 5.2
		15.600000000000001
		\prompt "bob" \textbf{+} "cat"
		'bobcat'
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Arithmetic operators}

	\begin{block}{Note}
		The division of two numbers returns by default the floor. Hence,
		\begin{semiverbatim}
			\prompt 5 / 2
			2
		\end{semiverbatim}

		\medskip
		It is possible to return the real value however, by telling Python that either the numerator or denominator is a real number:
		\begin{semiverbatim}
			\prompt 5.0 / 2
			2.5
			\prompt 5 / 2.0
			2.5
		\end{semiverbatim}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Arithmetic operators}

	Additional operators are modulo (\texttt{\%}) and power (\texttt{**}):

	\begin{semiverbatim}
		\prompt 26 * 4 + 3
		107
		\prompt 107 / 4
		26
		\prompt 107 \textbf{%} 4
		3
		\prompt 2 \textbf{**} 4
		16
		\prompt 10 \textbf{**} 3
		1000
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Arithmetic operators}
	Parentheses can be used to specify the order of operations (and also, to improve readability):

	\begin{semiverbatim}
		\prompt 3 + 4 * 2
		11
		\prompt \textbf{(}3 + 4\textbf{)} * 2
		14
	\end{semiverbatim}

	Python evaluates arithmetic operators in the following order: power, then multiplication, division, and modulo, then addition and subtraction, then boolean operators.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Boolean operators}

	Python can perform logical operations on booleans (i.e., values that are either true or false).

	\begin{block}{AND}
		\begin{semiverbatim}
			\prompt True and True
			True
			\prompt True and False
			False
			\prompt False and False
			False
			\prompt True and False
			False
		\end{semiverbatim}

		Other syntax: \texttt{\&}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Boolean operators}

	\begin{block}{OR}
		\begin{semiverbatim}
			\prompt True or True
			True
			\prompt True or False
			True
			\prompt False or False
			False
			\prompt False or True
			True
		\end{semiverbatim}

		Other syntax: $|$
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Boolean operators}

	\begin{block}{XOR}
		\begin{semiverbatim}
			\prompt True ^ True
			False
			\prompt True ^ False
			True
			\prompt False ^ False
			False
			\prompt False ^ True
			True
		\end{semiverbatim}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Boolean operators}

	\begin{block}{NOT}
		\begin{semiverbatim}
			\prompt not True
			False
			\prompt not False
			True
		\end{semiverbatim}
	\end{block}

	Note: Python evaluates boolean operators in the following order: negation, logical and, logical or.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Equalities}

	Value comparisons (equality `\texttt{==}', inequality `\texttt{!=}', less than `\texttt{<}', greater than `\texttt{>}', less than or equal to `\texttt{<=}', greater than or equal to `\texttt{>=}') can be performed, and combined with boolean operators:

	\begin{semiverbatim}
		\prompt 1 >= 2
		False
		\prompt (10 > 0) and (10 < 100)
		True
		\prompt (10 + 1) == 11
		True
		\prompt "bob" != "cat"
		True
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Subgroups}

	The \texttt{in} operator tests if a value is part of a list or a dictionary:

	\begin{semiverbatim}
		\prompt a = [1, 2, 3]
		\prompt b = \{ "blue": "bleu", "red": "rouge" \}
		\prompt 1 \textbf{in} a
		True
		\prompt "1" \textbf{in} a
		False
		\prompt "blue" \textbf{in} b
		True
		\prompt blue \textbf{in} b
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		NameError: name 'blue' is not defined
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Subgroups}

	Remember that strings are also considered as lists:

	\begin{semiverbatim}
		\prompt "Montana" \textbf{in} "Montana State University"
		True
	\end{semiverbatim}
\end{frame}

\begin{frame}
	\frametitle{Statements}
	\framesubtitle{Calls}

	Python provides numerous pieces of code, called \textit{functions}, to perform basic operations.

	\pause
	\medskip
	Any function has three properties: it is given a \textit{name}, it may accept \textit{inputs} or \textit{arguments} (data to process), and it may produce \textit{outputs} (results of the processing).

	\pause
	\medskip
	\begin{block}{Note}
		The term `function' stems from mathematics. A mathematical function is a relation between inputs and outputs (e.g., graph equation).
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Statements}
	\framesubtitle{Calls}

	A function is called by typing its name, followed by any input it accepts (if any) between parentheses. It may or may not return a value.

	\begin{semiverbatim}
		\prompt a = \textbf{range(}5\textbf{)}
		\prompt print a
		[0, 1, 2, 3, 4]
	\end{semiverbatim}

	The function \texttt{range} is provided by Python to generate a list of \textit{n} numbers starting (by default) from 0. Here, we called this functions with $n = 5$, and stored its output in the variable \textit{a}.
\end{frame}

\begin{frame}
	\frametitle{Statements}
	\framesubtitle{Calls}

	\begin{block}{Note}
		The \texttt{print} statement is actually a function, which purpose is to display the value of its inputs on the screen.

		\pause
		\bigskip
		For practical purpose, the Python authors decided not to ask programmers to use parentheses to delimitate the input(s) of this function. Thus, \texttt{print 1} should really be \texttt{print(1)}.
	\end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Flow control: Branching and Repetitions}

\begin{frame}{Flow control}
	A program is a list of instructions that the Python interpreter will read sequentially.

	\pause
	\bigskip
	However, it is possible to alter the flow of execution of these instructions in three ways:

	\begin{itemize}
		\pause
		\item By calling a function (the program `jumps' to the set of instructions contained in this function, then goes back to the point this function was called from)

		\pause
		\item By \textit{branching}; i.e., by choosing to execute a set of instructions over others based on the result of a statement

		\pause
		\item By \textit{repeating}; i.e., by choosing to execute a set of instructions a given number of times
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Branching: if, else}

	The \texttt{if} and \texttt{else} keywords allow for the conditional execution of sets of instructions based on the evaluation of a statement:

	\begin{semiverbatim}
	\textbf{if} \textit{statement}\textbf{:}
	  \comment{Set of instructions executed if the statement returns True}
	\textbf{else:}
	  \comment{Set of instructions executed if the statement returns False}
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Branching: elif}

	The \texttt{elif} keyword allows to test additional statements in case the previous one(s) return False:

	\begin{semiverbatim}
		\textbf{if} \textit{statement \#1}\textbf{:}
		  \comment{Set of instructions executed if statement \#1 returns True}
		\smallskip
		\textbf{elif} \textit{statement \#2}\textbf{:}
		  \comment{Set of instructions executed if statement \#1 returns False\\ and statement \#2 returns True}
		\smallskip
		\textbf{else:}
		  \comment{Set of instructions executed if statement \#1 and \#2\\ return False}
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Branching}

	Two syntax subtleties that you have to remember.

	\bigskip
	\begin{enumerate}
		\item There is a colon at the end of both \texttt{if}, \texttt{else} and \texttt{elif} statements. If you forget it, the Python interpreter will complain.

		\pause
		\medskip
		\item The sets of instructions that are executed have to be \textit{indented} using \textit{tabulations}. This is a Python specificity.
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Branching: Example}

	\begin{semiverbatim}
		score_msu = get_score("Montana State University")
		score_um = get_score("University of Montana")

		\textbf{if} (score_msu < score_um)\textbf{:}
		    print "How did this happen!?"
		    go_back_in_shame()		  
		\textbf{elif} (score_msu == score_um)\textbf{:}
		    print "They were lucky."
		\textbf{else:}
		    print "Yeah, that was obvious."
		    taunt()
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Repetition}

	The \texttt{for}, \texttt{in} and \texttt{while} keywords allow for the repeat execution of a set of instructions based either on the content of a variable (\texttt{for} and \texttt{in}) or the result of a statement (\texttt{while}):

	\pause
	\begin{semiverbatim}
		\textbf{for} variable \textbf{in} \textit{iterator}\textbf{:}
		  \comment{Set of instructions to execute for any value found\\ in the variable \texttt{\textit{iterator}}, or returned by a function}

		\pause
		\textbf{while} \textit{statement}\textbf{:}
		  \comment{Set of instructions to execute as long as the statement returns True}
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Repetition: for ... in ...}

	An iterator is either a \textit{variable} that contains a list of items, or a \textit{function} that returns a list of items. The variable name used between the \texttt{for} and \texttt{in} keywords will receive each of these items, one at a time:

	\begin{semiverbatim}
		\prompt \textbf{for} i \textbf{in} ["a", "b", "c"]\textbf{:}
		...     print i \comment{Do not forget the tabulation!}
		...
		a
		b
		c
		\prompt
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Repetition: for ... in ...}

	\begin{semiverbatim}
		\prompt \textbf{for} i \textbf{in} range(3)\textbf{:}
		...     print i
		...
		0
		1
		2
		\prompt
	\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Repetition: while}

	The \texttt{while} keyword is useful when a set of instructions have to be executed until some conditions are satisfied:

	\begin{semiverbatim}
		a = 0
		\textbf{while} (a < 5)\textbf{:}
		    print a
		    a = a + 1
	\end{semiverbatim}
\end{frame}

\begin{frame}
	\frametitle{Flow control}
	\framesubtitle{Special keywords}

	Two keywords can be used to control a flow from \textit{within} a \texttt{for} or \texttt{while} loop: \texttt{continue}, and \texttt{break}.

	\pause
	\bigskip
	The \texttt{continue} keyword asks Python to skip the remaining instructions, and to execute the next iteration.

	\pause
	\bigskip
	The \texttt{break} keyword asks Python to stop the iteration.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Special keywords: continue}

	\begin{semiverbatim}
		for i in range(5):
		  if (i == 3):
		    \textbf{continue}
		  print i
	\end{semiverbatim}

	... will result in showing 0, 1, 2, and 4. Because when \textit{i} equals 3, the program is told to skip all other instructions in the loop, including \texttt{print i}.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Flow control}
	\framesubtitle{Special keywords: break}

	\begin{semiverbatim}
		a = 0
		while (True): \comment{Will loop forever!}
		  if (a == 10):
		    \textbf{break}
		  print a
		  a = a + 1
	\end{semiverbatim}

	... will print all numbers from 0 to 9, then stop.
\end{frame}

\begin{frame}
	End of session 1.
\end{frame}

\end{document}
