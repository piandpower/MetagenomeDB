#!/usr/bin/env python

import optparse, sys, os, pprint

p = optparse.OptionParser(description = """Part of the MetagenomeDB toolkit.
Annotate objects in the database. Annotations are provided as either JSON- or
CSV-formatted files.""")

p.add_option("-i", "--input", dest = "input_fn", metavar = "FILENAME",
	help = "Name of the file containing the annotations")

p.add_option("-f", "--format", dest = "input_format", choices = ("json", "csv"), metavar = "STRING", default = "csv",
	help = "Format of the input file, either 'json' or 'csv' (default: %default)")

p.add_option("--ignore-missing", dest = "ignore_missing", action = "store_true", default = False,
	help = "If set, ignore relationships that points to missing objects")

p.add_option("--dry-run", dest = "dry_run", action = "store_true", default = False,
	help = "If set, process the input file but does not actually import the objects")

p.add_option("-v", "--verbose", dest = "verbose", action = "store_true", default = False)

g = optparse.OptionGroup(p, "Connection")

g.add_option("--host", dest = "connection_host", metavar = "HOSTNAME", default = "localhost",
	help = "Host name or IP address of the MongoDB server (optional; default: %default)")

g.add_option("--port", dest = "connection_port", metavar = "INTEGER", default = 27017,
	help = "Port of the MongoDB server (optional; default: %default)")

g.add_option("--db", dest = "connection_db", metavar = "STRING", default = "MetagenomeDB",
	help = "Name of the database in the MongoDB server (optional; default: '%default')")

g.add_option("--user", dest = "connection_user", metavar = "STRING", default = '',
	help = "User for the MongoDB server connection (optional; default: '%default')")

g.add_option("--password", dest = "connection_password", metavar = "STRING", default = '',
	help = "Password for the MongoDB server connection (optional; default: '%default')")

p.add_option_group(g)

(p, a) = p.parse_args()

def error (msg):
	if str(msg).endswith('.'):
		msg = str(msg[:-1])
	print >>sys.stderr, "ERROR: %s." % msg
	sys.exit(1)

if (p.input_fn == None):
	error("An input file must be provided")

if (not os.path.exists(p.input_fn)):
	error("File '%s' does not exists" % p.input_fn)

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

import MetagenomeDB as mdb

if (p.verbose):
	mdb.max_verbosity()

if (p.connection_host or p.connection_port or p.connection_db or p.connection_user or p.connection_password):
	mdb.connect(p.connection_host, p.connection_port, p.connection_db, p.connection_user, p.connection_password)

COLLECTIONS = {
	"collection": mdb.Collection,
	"sequence": mdb.Sequence,
}

class NotFound (Exception):
	pass

def key_filter (key):
	for k in key:
		if (k.startswith('_')):
			return False

	return True

def pull (map, key):
	value = map[key]
	del map[key]
	return value

n_annotated = 0

for entry in mdb.tools.parser(p.input_fn, p.input_format):
	try:
		type = pull(entry, "_type").lower()

		if (not type in COLLECTIONS):
			raise Exception("Unknown object type '%s'" % type)

		# _type=sequence, _collection='...', name='...', ...
		if (type == "sequence"):
			collection, name = pull(entry, "_collection"), entry["name"]

			# we first list all sequences having this name,
			candidates = mdb.Sequence.find({"name": name})

			# then we filter out those that are not linked to this collection
			candidates_ = filter(lambda s: s.count_collections({"name": collection}) > 0, candidates)

			if (len(candidates_) == 0):
				raise NotFound("Unknown Sequence '%s' in Collection '%s'" % (name, collection))

			if (len(candidates_) > 1):
				raise Exception("Duplicate Sequence '%s' in Collection '%s'" % (name, collection))

			objects = candidates_

		# _type=collection, name='...', ...
		elif (type == "collection"):
			candidate = mdb.Collection.find_one({"name": entry["name"]})

			if (candidate == None):
				raise NotFound("Unknown Collection '%s'" % entry["name"])
			else:
				objects = [candidate]

		for object in objects:
			entry_ = {}
			for key, value in mdb.tree.items(entry):
				# we ignore any key hierarchy which contains a
				# special key (i.e., key starting with a '_')
				if (not key_filter(key)):
					continue

				object[key] = value
				mdb.tree.set(entry_, key, value)

			if (object.is_committed()):
				print >>sys.stderr, "WARNING: Object %s has not been modified; annotations match database content." % object

			else:
				n_annotated += 1

				if (p.dry_run):
					print "annotate: %s" % type
					for line in pprint.pformat(entry_).split('\n'):
						print "  %s" % line
				else:
					object.commit()

	except mdb.errors.ConnectionError as msg:
		error(str(msg))

	except NotFound as msg:
		if (p.ignore_missing):
			print >>sys.stderr, "WARNING: %s" % msg
		else:
			error(msg)

	except Exception as msg:
		error("Invalid entry: %s. Entry was:\n %s" % (msg, pprint.pformat(entry)))

print "%s object%s annotated." % (n_annotated, {True: 's', False: ''}[n_annotated > 1])

if (p.dry_run):
	print "(dry run)"
