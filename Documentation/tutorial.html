<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title>MetagenomeDB Tutorial</title>
<style type="text/css">

BODY {
	margin: 0;
	padding: 10px;
	font-family: lucida grande, sans-serif;
	font-size: 13px;
	color: #000;
}

PRE {
	font-family: Fixedsys, Monaco, Courier;
	font-size: 9pt;
	padding: 2px 0 2px 7pt;
	border-left: 5px solid #d2f2f1;
	margin-left: 40px;
	color: #003f3f;
	background: #faffff;
	overflow: auto;
	width: 90%;
 }

CODE, TT {
	font-family: Fixedsys, Monaco, Courier;
	font-size: 9pt;
	color: #8F1D00;
 }

H1.title {
	margin-top: 0px;
	font-size: 18px;
	border: none;
}

H1 {
	font-size: 15px;
	border-bottom: 1px solid #aaa;
	margin-top: 20px;
}

H2 {
	font-size: 14px;
	margin-left: 20px;
	margin-top: 20px;
}

H3 {
	font-size: 13px;
	margin-left: 20px;
}

P {
	text-indent: 20px;
}

A, A:hover, A:visited {
	color: #000;
	text-decoration: none;
	text-transformation: none;
	border-bottom: 1px dashed #aaa;	
}

</style>
</head>
<body>
<div class="document" id="metagenomedb-tutorial">
<h1 class="title">MetagenomeDB Tutorial</h1>

<p>This is a tutorial for the <a class="reference external" href="http://github.com/ajmazurie/MetagenomeDB">MetagenomeDB</a> toolkit. MetagenomeDB allows to represent, manipulate and query metagenomic data using the <a class="reference external" href="http://www.python.org">Python</a> programming language. All the data are transparently handled by a <a class="reference external" href="http://www.mongodb.org">MongoDB</a> server, a professional-grade <a class="reference external" href="http://en.wikipedia.org/wiki/Document-oriented_database">document-oriented</a> database. This database is invisible for the user, who interacts with a high-level Python API. MetagenomeDB is also provided with a set of command-line tools to quickly add, remove and annotate objects in the database.</p>
<div class="section" id="fundamentals-sequences-collections-and-relationships">
<h1>1. Fundamentals: sequences, collections and relationships</h1>
<p>Imported as a Python library, MetagenomeDB exposes four classes: <tt class="docutils literal">Object</tt>, <tt class="docutils literal">Sequence</tt>, <tt class="docutils literal">Collection</tt> and <tt class="docutils literal">Relationship</tt>, which allow for the representation of virtually any kind of metagenomic data.</p>
<div class="section" id="sequences-sequence-class">
<h2>1.1. Sequences (<tt class="docutils literal">Sequence</tt> class)</h2>
<div class="section" id="annotations">
<h3>1.1.1. Annotations</h3>
<p>The <tt class="docutils literal">Sequence</tt> class stores sequences of any type (DNA, RNA or protein). In order to create a <tt class="docutils literal">Sequence</tt> object, a sequence and a name must be provided as arguments:</p>
<pre class="literal-block">
$ python
Python 2.6.4 (r264:75821M, Oct 27 2009, 19:48:32)
[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import MetagenomeDB as mdb
&gt;&gt;&gt; sequence = mdb.Sequence(sequence = &quot;atgc&quot;, name = &quot;my sequence&quot;)
</pre>
<p>Our sequence has now been declared. It has two properties: <tt class="docutils literal">sequence</tt>, which is a string that represents its sequence, and <tt class="docutils literal">name</tt>, which is whatever identifier you want to give it. The <tt class="docutils literal">get_properties()</tt> method will list all properties of this object:</p>
<pre class="literal-block">
&gt;&gt;&gt; print sequence.get_properties()
{'length': 4, 'name': 'my sequence', 'sequence': 'atgc'}
</pre>
<p>Note that a third property, <tt class="docutils literal">length</tt> has been added; it is automatically inferred from the sequence when not explicitly provided.</p>
<p>A <tt class="docutils literal">Sequence</tt> object (and whatever object in MetagenomeDB) is not limited to those three properties. You can add and modify any property by manipulating your object as a <a class="reference external" href="http://docs.python.org/tutorial/datastructures.html#dictionaries">dictionary</a>:</p>
<pre class="literal-block">
&gt;&gt;&gt; sequence[&quot;my_property&quot;] = 3
&gt;&gt;&gt; print sequence[&quot;my_property&quot;]
3
&gt;&gt;&gt; sequence[&quot;my_property&quot;] = [1,2,3]
&gt;&gt;&gt; print sequence.get_properties()
{'my_property': [1,2,3], 'length': 4, 'name': 'my sequence', 'sequence': 'atgc'}
&gt;&gt;&gt; &quot;my_property&quot; in sequence
True
&gt;&gt;&gt; del sequence[&quot;my_property&quot;]
</pre>
<p>MetagenomeDB supports nested properties; i.e., properties that are children of other properties. Creating such a nested property requires the use of the dot notation:</p>
<pre class="literal-block">
&gt;&gt;&gt; sequence[&quot;my_property.my_subproperty&quot;] = &quot;something&quot;
&gt;&gt;&gt; print sequence.get_properties()
&gt;&gt;&gt; {'my_property': {'my_subproperty': 'something'}, 'length': 4, 'name': 'my sequence', 'sequence': 'atgc'}
</pre>
<p>Note that the property <tt class="docutils literal">my_property</tt> now has a sub-property <tt class="docutils literal">my_subproperty</tt>. Accessing and modifying this sub-property can be done user either the dot notation or a more traditional Python dictionary notation:</p>
<pre class="literal-block">
&gt;&gt;&gt; print sequence[&quot;my_property&quot;][&quot;my_subproperty&quot;]
'something'
&gt;&gt;&gt; print sequence[&quot;my_property.my_subproperty&quot;]
'something'
&gt;&gt;&gt; sequence[&quot;my_property&quot;][&quot;my_subproperty&quot;] = &quot;something else&quot;
&gt;&gt;&gt; sequence[&quot;my_property.my_subproperty&quot;] = &quot;something different&quot;
</pre>
<p>Such nested properties are useful to group related properties; e.g., information about who produced this sequence, and how:</p>
<pre class="literal-block">
&gt;&gt;&gt; sequence[&quot;author.name&quot;] = &quot;me&quot;
&gt;&gt;&gt; sequence[&quot;author.institution&quot;] = &quot;my employer&quot;
&gt;&gt;&gt; print sequence[&quot;author&quot;]
{'name': 'me', 'institution': 'my employer'}
</pre>
</div>
<div class="section" id="commit">
<h3>1.1.2. Commit</h3>
<p>At this stage the sequence object you created and annotated exists only in the memory of your computer. It is <cite>uncommitted</cite>, as shown when printing the sequence description:</p>
<pre class="literal-block">
&gt;&gt;&gt; print sequence
&lt;Sequence id:none name:'my sequence' length:4 state:'uncommitted'&gt;
</pre>
<p>To <cite>commit</cite> this object to the database, just call its <tt class="docutils literal">commit()</tt> method:</p>
<pre class="literal-block">
&gt;&gt;&gt; sequence.commit()
&gt;&gt;&gt; print sequence
&lt;Sequence id:4be9b417aeba8aa576000000 name:'my sequence' length:4 state:'committed'&gt;
</pre>
<p>Your object received an internal identifier, which prove it was stored into the database. If you happen to modify this object <cite>after</cite> it is committed, you will need to commit it again to store the modifications:</p>
<pre class="literal-block">
&gt;&gt;&gt; del sequence[&quot;author&quot;]
&gt;&gt;&gt; print sequence
&lt;Sequence id:4be9b417aeba8aa576000000 name:'my sequence' length:4 state:'uncommitted'&gt;
&gt;&gt;&gt; sequence.commit()
&gt;&gt;&gt; print sequence
&lt;Sequence id:4be9b417aeba8aa576000000 name:'my sequence' length:4 state:'committed'&gt;
</pre>
<p>To know if an object was committed after its latest modification, you can either read its description or call <tt class="docutils literal">is_committed()</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; print sequence.is_committed()
True
</pre>
</div>
<div class="section" id="querying">
<h3>1.1.3. Querying</h3>
<p>Sequences that have been committed can be queried based on any of their properties. It is important to note that uncommitted objects are <cite>not</cite> visible by those queries.</p>
<p>Two methods of the <tt class="docutils literal">Sequence</tt> class are available to query sequences: <tt class="docutils literal">find()</tt>, and <tt class="docutils literal">find_one()</tt>. The former returns all sequences that match the query, while the latter returns only the first. This can be useful when you know there is only one sequence that can match your query.</p>
<p>Queries are expressed as a filter; i.e., you provide a set of properties and the values you are looking for, and MetagenomeDB will return the sequences that match:</p>
<pre class="literal-block">
&gt;&gt;&gt; mdb.Sequence.find_one(name = &quot;my sequence&quot;)
&lt;Sequence id:4be9b417aeba8aa576000000 state:committed name:'my sequence' len:4&gt;
&gt;&gt;&gt; list(mdb.Sequence.find(length = 4))
[&lt;Sequence id:4be9b417aeba8aa576000000 state:committed name:'my sequence' len:4&gt;]
</pre>
<p>Note: the <tt class="docutils literal">find_one()</tt> method returns the object that match your query, or <tt class="docutils literal">None</tt> if there is none. However the <tt class="docutils literal">find()</tt> method returns a list of objects as a Python <a class="reference external" href="http://en.wikipedia.org/wiki/Iterator#Python">generator</a>:</p>
<pre class="literal-block">
&gt;&gt;&gt; for s in mdb.Sequence.find(length = 4):
&gt;&gt;&gt;     print s
&lt;Sequence id:4be9b417aeba8aa576000000 state:committed name:'my sequence' len:4&gt;
</pre>
<p>You can query for several properties at once:</p>
<pre class="literal-block">
&gt;&gt;&gt; list(mdb.Sequence.find(length = 4, my_property = &quot;something&quot;))
</pre>
<p>Note: Due to technical limitations, nested properties cannot be queried using dot notation:</p>
<pre class="literal-block">
&gt;&gt;&gt; list(mdb.Sequence.find(my_property.my_subproperty = &quot;something&quot;))
  File &quot;&lt;stdin&gt;&quot;, line 1
SyntaxError: keyword can't be an expression
</pre>
<p>Instead, you must declare them as nested dictionaries:</p>
<pre class="literal-block">
&gt;&gt;&gt; list(mdb.Sequence.find(my_property = {&quot;my_subproperty&quot;: &quot;something&quot;}}))
</pre>
<p>This command will select all sequences of which nested property <tt class="docutils literal">my_property.my_subproperty</tt> is equal to 'something'.</p>
<p><cite>TODO: Do something about this; maybe by allowing some syntactic sugar?</cite></p>
</div>
<div class="section" id="related-objects">
<h3>1.1.4. Related objects</h3>
<p>A <tt class="docutils literal">Sequence</tt> can be part of a <tt class="docutils literal">Collection</tt> , or be related to other sequences</p>
</div>
</div>
<div class="section" id="collections">
<h2>1.2. Collections</h2>
<p>The <tt class="docutils literal">Collection</tt> object represents a collection of <tt class="docutils literal">Sequence</tt> and/or <tt class="docutils literal">Collection</tt> objects. In metagenomic a <tt class="docutils literal">Collection</tt> will typically represents a collection of reads produced by a sequencing run, or a set of contigs produced by an assembly.</p>
<p>The only mandatory property when creating a <tt class="docutils literal">Collection</tt> object is a <tt class="docutils literal">name</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; c = mdb.Collection(name = &quot;my collection&quot;)
</pre>
<p>In addition to the methods mentioned earlier, <tt class="docutils literal">Collection</tt> classes have these additional methods:</p>
<p><tt class="docutils literal">add_sequence()</tt> will add an existing <tt class="docutils literal">Sequence</tt> object to the collection:</p>
<pre class="literal-block">
&gt;&gt;&gt; s = mdb.Sequence.find_one(name = &quot;my_sequence&quot;)
&gt;&gt;&gt; c.add_sequence(s)
</pre>
<p><cite>TODO: to implement</cite></p>
<p><tt class="docutils literal">remove_sequence()</tt> will remove an existing <tt class="docutils literal">Sequence</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; c.remove_sequence(s)
</pre>
<p><cite>TODO: to implement</cite></p>
</div>
<div class="section" id="relationships">
<h2>1.3. Relationships</h2>
<p>Bla</p>
</div>
<div class="section" id="anonymous-objects">
<h2>1.4. Anonymous objects</h2>
<p>The <tt class="docutils literal">Object</tt> class can be used to represent any biological object that would not be a <tt class="docutils literal">Sequence</tt>, <tt class="docutils literal">Collection</tt> or <tt class="docutils literal">Relationship</tt>.</p>
<p>A typical example is a reference to a public database when importing BLAST results. Whenever a BLAST is performed against sequences that are not registered in MetagenomeDB, the resulting BLAST output cannot be interpreted as a <tt class="docutils literal">Relationship</tt> between two <tt class="docutils literal">Sequence</tt> objects. The reason is that either the query or the hit is a sequence unknown of MetagenomeDB; i.e., an 'anonymous' object.</p>
<p>To allow for the representation of those anonymous objects the <tt class="docutils literal">Object</tt> class can be used. Its behavior is exactly the same at those of the other three object classes. I.e., an anonymous object can be annotated, committed to the database, and related to other objects (either anonymous, or other <tt class="docutils literal">Sequence</tt> or <tt class="docutils literal">Collection</tt>).</p>
<p>Both <tt class="docutils literal">import.FASTA</tt> and <tt class="docutils literal">import.BLAST</tt> tools (see section X.X) use <tt class="docutils literal">Object</tt> when importing alignments between sequences in the database and sequences outside of the database.</p>
</div>
</div>
<div class="section" id="importing-and-manipulating-sequences">
<h1>2. Importing and manipulating sequences</h1>
<div class="section" id="importing-sequences">
<h2>2.1. Importing sequences</h2>
<p>Let's consider the following <a class="reference external" href="http://en.wikipedia.org/wiki/FASTA_format">FASTA</a>-formatted file <tt class="docutils literal">my_sequences.fasta</tt>:</p>
<pre class="literal-block">
&gt;contig00001  numreads=171
TTCTTCACGTGGGAGTGCGTGTCCCACAAGGTCGCGGGTCTACCCTTACGGGAACCCCGC
TTAAGTAGGAGTTAGTGCACAATAATTTAACGTTTTCGGTTCCTATACAGCTCAGAGCTG
TAAGAAATAAAGTTTAAAACTGCAAATATAAAGCCATAACACATGAAAAAGATAACAATA
AACATTGATGAAAAACTAAAGGAGGTTTTTTCTAGATTATGTGAAGAGGAAGGGGTAGAT
ATGGCTCAGGGTATAAGGGAGTTAATTATTGAGGCAATAAATAGGGGCTATATAAACAAG
CAGAGGAAAGAAGGCGTAGAAAAGGTGAGAAAAAACAAGTGAACAATCACACTTCGATTG
TTTTGCAACTTAGGATACAAAAAGAACAGTGC
&gt;contig00002  numreads=13
ttAGGGTTCTTTTCGGCGAGTTTTCTGGTATCCTCAATTTGTTCGTACAGTTCCTTGATA
GGGTTCTCAAAATCAAGGAATTGTCTGTTTGGGTATTGGGGCATAATGATCGTTTAGAAC
GGTAAAATTAGGGGTTCAGATTTTTtCCTGAAAaGATTtGTTTATGAAAAGTCTTTACCC
TTATCTTTGCCGTCCCGAAAACGGACTGAAAGGGATGTTTTTAGGATGATATAACTGGTT
TCCCAGTAATCACGGATCGGTAGTTCAGTTGGTTATCTCGCCTTAGGCGAGACGCCCTGA
GAAAGGCTCTTTTAAATGATTATGTTCTATACTTACATCATAGTAAATAATGATGGTATA
TTCTATAAGGGAAGTACCTCAGACTTTGAGAAAAGGTTAGAACAACACAACGCCGGACTC
AGTCACTACACTAGAGGCAGAGGGCCTTGGAaGCTGGTTTTTGTTCAGGCTTTCtCTTCA
CAAATTGAGGCTGAAGCCTTGGAAAAACGGCTAAAgCGTTGTAATAAAGATTATTTAAAC
TGGTTAATTAAACAaCCAGTTAATATATTGGATCGGTAGTTCAGTTGGTTAGAATGCCG
</pre>
<p>In order to manipulate those sequences we first need to import them into the MetagenomeDB database. A utility, <tt class="docutils literal">import.sequences</tt> is available in the <tt class="docutils literal">Tools/</tt> subdirectory to do so.</p>
<p><tt class="docutils literal">import.sequences</tt> can read sequences in a variety of formats (see <a class="reference external" href="http://www.biopython.org/wiki/SeqIO#File_Formats">here</a> for a list); by default, it expects FASTA files. To list all its options, type <tt class="docutils literal">./import.sequences <span class="pre">--help</span></tt>:</p>
<pre class="literal-block">
$ cd path_to_metagenomedb_installation/Tools
$ ./import.sequences --help
Usage: import.sequences [options]

Part of the MetagenomeDB toolkit. Imports nucleotide or aminoacid sequences
into the database. Those sequences can be in any format supported by Biopython
(see http://biopython.org/wiki/SeqIO).

Options:
  -h, --help            show this help message and exit
  -v VERBOSITY, --verbosity=VERBOSITY

  Sequences:
    -i FILENAME, --input=FILENAME
                        Sequences to import.
    -f STRING, --format=STRING
                        Format of the sequences file. Default: fasta
    -s KEY VALUE, --sequence-property=KEY VALUE
                        Custom sequence property (optional).

  Collection:
    -C STRING, --collection-name=STRING
                        Name of the collection the sequences belong to.
    -c KEY VALUE, --collection-property=KEY VALUE
                        Description of the collection the sequences belong to,
                        as a key/value (optional).
    -r KEY VALUE, --relationship-property=KEY VALUE
                        Custom sequence-to-collection relationship property
                        (optional).
</pre>
<p>Two information must be provided to import sequences: the name of the sequence file (<tt class="docutils literal"><span class="pre">-i</span></tt> or <tt class="docutils literal"><span class="pre">--input</span></tt>), and the <tt class="docutils literal">Collection</tt> the sequences will belong to. The <tt class="docutils literal">Collection</tt> can be either pre-existing; in this case, you can provide its name with the <tt class="docutils literal"><span class="pre">-C</span></tt> or <tt class="docutils literal"><span class="pre">--collection-name</span></tt> option. Or it can be created on the fly, using your own definition (<tt class="docutils literal"><span class="pre">-c</span></tt> or <tt class="docutils literal"><span class="pre">--collection-property</span></tt> option). Note: all sequences in the file will be assigned the same <tt class="docutils literal">Collection</tt>.</p>
<p>Let imagine a collection named <tt class="docutils literal">my_collection</tt> already exists. Then importing <tt class="docutils literal">my_sequences.fasta</tt> is then as easy as:</p>
<pre class="literal-block">
$ ./import.sequences -i path_to/my_sequences.fasta -C my_collection
</pre>
<p>If <tt class="docutils literal">my_collection</tt> didn't exist, you could have created it with the following command line:</p>
<pre class="literal-block">
$ ./import.sequences -i path_to/my_sequences.fasta -c name my_collection
</pre>
<p>In this case, a collection with name 'my_collection' is created prior to the sequences importation. In case the collection already exists an error will be thrown:</p>
<pre class="literal-block">
$ ./import.sequences -i path_to/my_sequences.fasta -c name my_collection
</pre>
</div>
</div>
<div class="section" id="importing-and-manipulating-alignments">
<h1>3. Importing and manipulating alignments</h1>
</div>
<div class="section" id="advanced-manipulations">
<h1>4. Advanced manipulations</h1>
<ul class="simple">
<li>traverse neighbors (e.g., is there any sequence in any of my descendant collections that have such and such property?)</li>
</ul>
</div>
</div>
</body>
</html>
