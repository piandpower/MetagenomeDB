#!/usr/bin/env python

# TODO: I read somewhere there is a limit of 4Mb per object. Check this value,
#   and ensure an error is thrown when a sequence is too big
# TODO: Use BioPython to access a broader variety of input sequences format and
#   to automatically recognize the class of sequence

import optparse, sys, os, json

p = optparse.OptionParser()

g = optparse.OptionGroup(p, "Sequences")

g.add_option("-i", "--input", dest = "input_fn", metavar = "FILENAME",
	help = "Sequences to import (FASTA format).")

g.add_option("-t", "--sequences-type", dest = "sequences_type", choices = ("dna", "rna", "protein"),
	help = "Sequences type ('dna', 'rna' or 'protein').")

g.add_option("-p", "--sequence-property", dest = "sequence_properties", nargs = 2, action = "append", metavar = "KEY VALUE",
	help = "Custom sequence property (optional).")

p.add_option_group(g)

g = optparse.OptionGroup(p, "Collection")

g.add_option("--collection-id", dest = "collection_id", metavar = "ID",
	help = "Identifier of the collection the sequences belong to (optional).")

g.add_option("--collection-name", dest = "collection_name", metavar = "STRING",
	help = "Name of the collection the sequences belong to (optional).")

g.add_option("--collection", dest = "collection_fn", metavar = "FILENAME",
	help = "Description of the collection the sequences belong to, as a JSON-formatted text file (optional).")

g.add_option("-c", "--collection-property", dest = "collection_properties", nargs = 2, action = "append", metavar = "KEY VALUE",
	help = "Description of the collection the sequences belong to, as a key/value (optional).")

g.add_option("-P", "--relationship-property", dest = "relationship_properties", nargs = 2, action = "append", metavar = "KEY VALUE",
	help = "Custom sequence-to-collection relationship property (optional).")

p.add_option_group(g)

p.add_option("-v", "--verbosity", dest = "verbosity", type = "int", default = 0)

(p, a) = p.parse_args()

def error (msg):
	print >>sys.stderr, "ERROR: %s." % msg
	sys.exit(1)

if (p.input_fn == None):
	error("A FASTA-formated sequence file must be provided")

if (not os.path.exists(p.input_fn)):
	error("File '%s' not found" % p.input_fn)

if (p.sequence_properties):
	for key, value in p.sequence_properties:
		if (key in ("name", "description", "length", "sequence", "type")):
			error("The key '%s' is reserved" % key)

if ((p.collection_id != None) + (p.collection_fn != None) + (p.collection_properties != None)) > 1:
	error("A collection identifier OR a collection description can be provided, but not both")

if (p.collection_fn) and (not os.path.exists(p.collection_fn)):
	error("File '%s' not found" % p.collection_fn)

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

import MetagenomeDB as mdb

if (p.verbosity > 0):
	mdb.set_debug_level(p.verbosity)

if (p.collection_id):
	try:
		collection = mdb.Collection.select(p.collection_id)
	except ValueError:
		error("Invalid identifier '%s'" % p.collection_id)

	if (collection == None):
		error("Unknown Collection object with id '%s'" % p.collection_id)

elif (p.collection_name):
	collection = mdb.Collection.find_one({ "name": p.collection_name })

	if (collection == None):
		error("Unknown Collection object with name '%s'" % p.collection_name)

elif (p.collection_fn):
	try:
		collection = mdb.Collection.from_json(p.collection_fn)

		if ("_id" in collection):
			print "WARNING: A '_id' field was found in %s and removed." % p.collection_fn

			del collection["_id"]

	except Exception, msg:
		error("Malformed collection description: %s" % msg)

elif (p.collection_properties):
	m = {}
	for (key, value) in p.collection_properties:
		m[key] = value

	if ("_id" in m):
		error("Reserved field '_id'")

	try:
		collection = mdb.Collection.from_dict(m)
	
	except ValueError, msg:
		error("Malformed collection description: %s" % msg)

else:
	collection = None

if (p.relationship_properties):
	m = {}
	for (key, value) in p.relationship_properties:
		m[key] = value

	p.relationship_properties = m
else:
	p.relationship_properties = {}

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

from bioformat import FastaReader

print "Importing '%s' ..." % p.input_fn

n = 0
for (id, annotation, sequence) in FastaReader(p.input_fn):
	entry = {
		"name": id,
		"sequence": sequence,
		"type": p.sequences_type,
		"length": len(sequence),
	}

	if (annotation != None):
		entry["description"] = annotation.strip()

	if (p.sequence_properties):
		for (key, value) in p.sequence_properties:
			if (key in entry):
				error("Reserved field '%s'" % key)

			entry[key] = value

	sequence = mdb.Sequence.from_dict(entry)
	sequence.commit()
	n += 1

	if (collection):
		mdb.Relationship(sequence, collection, "part-of", **p.relationship_properties).commit()

	if (n % 1000 == 0):
		print "  (%s sequences imported)" % n

print "\n  %s sequences imported." % n
