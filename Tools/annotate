#!/usr/bin/env python

import optparse, sys, os, pprint
import MetagenomeDB as mdb

p = optparse.OptionParser(description = """The 'annotate' tool is part of the
MetagenomeDB toolkit. Its purpose is to annotate objects already present in the
database. It reads annotations in either JSON or CSV format (see
http://www.json.org/ for an introduction to the JSON format).""")

p.add_option("-i", "--input", dest = "input_fn", metavar = "FILENAME",
	help = "Name of the file containing the annotations")

p.add_option("-f", "--format", dest = "input_format", choices = ("json", "csv"), metavar = "STRING", default = "json",
	help = "Format of the input file, either 'json' or 'csv' (default: %default)")

p.add_option("--ignore-missing", dest = "ignore_missing", action = "store_true", default = False,
	help = "If set, ignore relationships that points to missing objects")

p.add_option("--dry-run", dest = "dry_run", action = "store_true", default = False,
	help = "If set, process the input file but does not actually import the objects")

p.add_option("-v", "--verbosity", dest = "verbosity", type = "int", default = 0)

(p, a) = p.parse_args()

def error (msg):
	print >>sys.stderr, "ERROR: %s." % msg
	sys.exit(1)

if (p.input_fn == None):
	error("An input file must be provided")

if (not os.path.exists(p.input_fn)):
	error("File '%s' does not exists" % p.input_fn)

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

if (p.verbosity > 0):
	mdb.set_debug_level(p.verbosity)

mdb.show_warnings(False)

COLLECTIONS = {
	"Collection": mdb.Collection,
	"Sequence": mdb.Sequence,
	"Relationship": mdb.Relationship,
}

class NotFound (Exception):
	pass

def key_filter (key):
	for k in key:
		if (k.startswith('@')):
			return False

	return True

n = 0
for entry in mdb.tools.parser(p.input_fn, p.input_format):
	try:
		type = entry["@type"]

		if (not type in COLLECTIONS):
			raise Exception("Unknown object type '%s'" % type)

		if (type == "Sequence"):
			collection, name = entry["@collection"], entry["@name"]

			# we first list all sequences having this name,
			candidates = mdb.Sequence.find(name = name)
			# then we filter out those that are not linked to this collection
			objects = filter(lambda x: len(list(x.get_collections({ "name": collection }))) > 0, candidates)
			c = len(objects)

			if (c == 0):
				raise NotFound("Unknown Sequence '%s' in Collection '%s'" % (name, collection))

			if (c > 1):
				raise Exception("Duplicate Sequence '%s' in Collection '%s'" % (name, collection))

		if (type == "Collection"):
			name = entry["@name"]

			objects = [mdb.Collection.find_one(name = name)]

			if (len(c) == 0):
				raise NotFound("Unknown Collection '%s'" % name)

		if (type == "Relationship"):
			raise NotImplementedError
		
		if (p.dry_run):
			continue

		for object in objects:
			for key, value in mdb.tree.keys(entry):
				# we ignore any key hierarchy which contains a
				# special key (i.e., key starting with a '@')
				if (not key_filter(key)):
					continue

				object[key] = value

			if (not object.is_committed()):
				n += 1

			object.commit()

	except mdb.errors.ConnectionError as msg:
		error(str(msg))

	except NotFound as msg:
		if (p.ignore_missing):
			print >>sys.stderr, "WARNING: %s" % msg
		else:
			error(msg)

	except Exception as msg:
		error("Invalid entry: %s. Entry was:\n %s" % (msg, pprint.pformat(entry)))

print "%s object%s annotated." % (n, { True: 's', False: '' }[n > 1])

if (p.dry_run):
	print "(dry run)"
